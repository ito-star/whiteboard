const admin = require("firebase-admin");
// eslint-disable-next-line no-underscore-dangle
const _isPlainObject = require("lodash/isPlainObject");
// eslint-disable-next-line no-underscore-dangle
const _keyBy = require("lodash/keyBy");
const LRU = require("lru-cache");
const { BlockTypes, getBlockDefaults } = require("./constant");

const PAID_ROLES = ["basic", "premium", "premium-plus"];
const getRole = (user) => {
  const customClaims = user.customClaims || {};
  if (customClaims.isSpecial) {
    return "special";
  }

  if (user.isAnonymous) {
    return "anonymous";
  }

  if (PAID_ROLES.includes(customClaims.stripeRole)) {
    return customClaims.stripeRole;
  }

  return "free";
};

/**
 * Transform a user ID into an email address
 *
 * This is the reverse of emailToId().
 */
exports.idToEmail = (id) => {
  const email = id.replace(/<>/g, ".");
  return email;
};

/**
 * Get a Firebase Storage File Reference from a URL
 *
 * Based on https://github.com/firebase/firebase-js-sdk/blob/17a477c123ea4447d1012f2df783986839ec9bd8/packages/storage/src/implementation/location.ts#L70
 *
 * @param {String} url
 * @returns { import("@google-cloud/storage").File || null }
 */
exports.fileFromUrl = (url) => {
  let location = null;
  const bucketDomain = "([A-Za-z0-9.\\-_]+)";

  function gsModify(loc) {
    if (loc.path.charAt(loc.path.length - 1) === "/") {
      // eslint-disable-next-line no-param-reassign
      loc.path = loc.path.slice(0, -1);
    }
  }

  const gsPath = "(/(.*))?$";
  const gsRegex = new RegExp(`^gs://${bucketDomain}${gsPath}`, "i");
  const gsIndices = { bucket: 1, path: 3 };

  function httpModify(loc) {
    // eslint-disable-next-line no-param-reassign
    loc.path = decodeURIComponent(loc.path);
  }

  const version = "v[A-Za-z0-9_]+";
  const firebaseStorageHost = "firebasestorage.googleapis.com".replace(
    /[.]/g,
    "\\."
  );
  const firebaseStoragePath = "(/([^?#]*).*)?$";
  const firebaseStorageRegExp = new RegExp(
    `^https?://${firebaseStorageHost}/${version}/b/${bucketDomain}/o${firebaseStoragePath}`,
    "i"
  );
  const firebaseStorageIndices = { bucket: 1, path: 3 };

  const cloudStorageHost =
    "(?:storage.googleapis.com|storage.cloud.google.com)";
  const cloudStoragePath = "([^?#]*)";
  const cloudStorageRegExp = new RegExp(
    `^https?://${cloudStorageHost}/${bucketDomain}/${cloudStoragePath}`,
    "i"
  );
  const cloudStorageIndices = { bucket: 1, path: 2 };

  const groups = [
    { regex: gsRegex, indices: gsIndices, postModify: gsModify },
    {
      regex: firebaseStorageRegExp,
      indices: firebaseStorageIndices,
      postModify: httpModify,
    },
    {
      regex: cloudStorageRegExp,
      indices: cloudStorageIndices,
      postModify: httpModify,
    },
  ];

  // eslint-disable-next-line no-plusplus
  for (let i = 0; i < groups.length; i++) {
    const group = groups[i];
    const captures = group.regex.exec(url);

    if (captures) {
      const bucketValue = captures[group.indices.bucket];
      let pathValue = captures[group.indices.path];

      if (!pathValue) {
        pathValue = "";
      }

      location = { bucket: bucketValue, path: pathValue };
      group.postModify(location);
      break;
    }
  }

  if (location == null) {
    return null;
  }

  const defaultBucket = admin.app().options.storageBucket;

  if (location.bucket !== defaultBucket) {
    return null;
  }

  return admin.storage().bucket(location.bucket).file(location.path);
};

exports.encodeFilePath = (filePath) => {
  return encodeURIComponent(filePath).replace(/\./g, "%2E");
};

/**
 * Get a Firebase user by email or UID
 *
 * @param {string} email
 * @param {boolean} isUid
 * @returns {Promise<import("firebase-admin").auth.UserRecord>}
 */
exports.getUser = async (email, isUid) => {
  let user;

  if (isUid) {
    user = await admin.auth().getUser(email);
  } else {
    user = await admin.auth().getUserByEmail(email);
  }

  return user;
};

exports.getUidOptionParams = () => {
  return ["-u, --uid", "Use Firebase UID instead of email"];
};

/**
 * Converts a Firebase Realtime Database collection into an `Array`
 *
 * Collections in Firebase Realtime Database come in two forms:
 *
 * 1. `Array`s
 * 2. `Object`s with keys that are IDs generated by Firebase Realtime Database.
 *    This is kind that gets created when you do `firebase.database().ref('foobar').push()`.
 *
 * Type #1 is returned as an `Array`. Type #2 is returned as an `Object`. This function
 * ensures that we can work with each type of collection as an `Array`.
 *
 * @param {Array|Object} collection
 * @returns {Array}
 */
const dbCollectionToArray = (collection) => {
  if (Array.isArray(collection)) {
    return collection;
  }

  if (_isPlainObject(collection)) {
    return Object.values(collection);
  }

  return [];
};

exports.dbCollectionToArray = dbCollectionToArray;

const getBlockUrlProp = (block) => {
  const filesProps = {
    [BlockTypes.Image]: "image_path",
    [BlockTypes.PDF]: "pdf_path",
  };
  const filesProp = filesProps[block.type];

  return filesProp;
};

exports.getBlockUrlProp = getBlockUrlProp;

const getBlockFilesProp = (block) => {
  const filesProps = {
    [BlockTypes.Image]: "imageFiles",
    [BlockTypes.PDF]: "pdfFiles",
    [BlockTypes.Files]: "files",
    [BlockTypes.Text]: "textEditorFiles",
    [BlockTypes.FileRequest]: "fileRequestFiles",
    [BlockTypes.Grid]: "gridFiles",
  };
  const filesProp = filesProps[block.type];

  return filesProp;
};

exports.getBlockFilesProp = getBlockFilesProp;

const getBlockFilesDefault = (block, raw) => {
  const filesProp = getBlockFilesProp(block);
  const blockDefaults = getBlockDefaults();

  const defaultValue = blockDefaults[filesProp];

  if (raw) {
    return defaultValue;
  }

  return dbCollectionToArray(defaultValue);
};

exports.getBlockFilesDefault = getBlockFilesDefault;

const getBlockFiles = (block, raw) => {
  const filesProp = getBlockFilesProp(block);

  const value = block[filesProp];

  if (value) {
    if (raw) {
      return value;
    }

    return dbCollectionToArray(value);
  }

  return getBlockFilesDefault(block, raw);
};

exports.getBlockFiles = getBlockFiles;

const blockFilesArrayToRaw = (block, files) => {
  const rawDefaultValue = getBlockFilesDefault(block, true);

  if (!files || !files.length) {
    return rawDefaultValue;
  }

  if (Array.isArray(rawDefaultValue)) {
    return files;
  }

  return _keyBy(files, "id");
};

exports.blockFilesArrayToRaw = blockFilesArrayToRaw;

let ROLES;

const getRoles = async () => {
  if (ROLES === undefined) {
    const rolesRef = admin.database().ref("roles");
    const rolesSnap = await rolesRef.once("value");
    if (!rolesSnap.exists()) {
      throw new Error(
        "Cannot find role information. To setup role information, follow the instructions in README to set up admin scripts, then run the command `npm run --silent admin -- init-roles`"
      );
    }
    ROLES = rolesSnap.val();
  }
  return ROLES;
};

exports.getRoles = getRoles;

exports.getRoleLoadLimits = async (user) => {
  const roles = await getRoles();
  const role = getRole(user);
  return roles[role].maxBoardLoads;
};

exports.getCache = () => new LRU({ max: 500 });
